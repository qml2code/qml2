from pyscf import scf

negligible_coord_diff = 1.0e-8

# Everything related to convenient handling of ab initio data.

# Internal format for processing AOs.
orb_ang_mom = {"s": 0, "p": 1, "d": 2, "f": 3, "g": 4, "h": 5, "i": 6}


# Base classes used by oml_compound and adaptive_basis_sets modules.
class OML_pyscf_calc_params:
    #   Parameters of pySCF calculations.
    def __init__(
        self,
        orb_max_iter=5000,
        orb_grad_tol=1.0e-8,
        scf_max_cycle=50,
        so_scf_max_cycle=5000,
        scf_conv_tol=1e-9,
        scf_conv_tol_grad=None,
    ):
        """
        During an SCF calculation the code first runs scf_max_cycle SCF cycles
        (by default same number as normal SCF), if that failes it runs so_scf_max_cycle
        second order SCF cycles.
        """
        self.orb_kwargs = {"max_iter": orb_max_iter, "grad_tol": orb_grad_tol}
        self.scf_max_cycle = scf_max_cycle
        self.so_scf_max_cycle = so_scf_max_cycle
        self.scf_conv_tol = scf_conv_tol
        self.scf_conv_tol_grad = scf_conv_tol_grad


def pySCFNotConvergedErrorMessage(
    pyscf_calc_params: OML_pyscf_calc_params | None = None, mats_savefile=None
):
    message = "WARNING: A SCF calculation failed to converge."
    if pyscf_calc_params is not None:
        message += (
            " Number of cycles: "
            + str(pyscf_calc_params.scf_max_cycle)
            + "(first order) and "
            + str(pyscf_calc_params.so_scf_max_cycle)
            + " (second_order)."
        )
    if mats_savefile is not None:
        message += " Problematic mats_savefile: " + mats_savefile
    return message


class pySCFNotConvergedError(Exception):
    pass


def converged_mf(
    mf,
    pyscf_calc_params=OML_pyscf_calc_params(),
    dm_init_guess=None,
    use_Huckel=False,
    mats_savefile=None,
    use_gpu=False,
):
    mf.conv_tol = pyscf_calc_params.scf_conv_tol
    if use_Huckel:
        mf.init_guess = "huckel"
        mf.max_cycle = -1
    else:
        mf.max_cycle = pyscf_calc_params.scf_max_cycle
    if dm_init_guess is None:
        mf.run()
    else:
        mf.kernel(dm_init_guess)
    if use_gpu:
        mf = mf.to_cpu()
    if not (mf.converged or use_Huckel):
        mf = scf.newton(mf)
        mf.max_cycle = pyscf_calc_params.so_scf_max_cycle
        mf.run()
        if mf.converged:
            print("SCF converged with SO-SCF.")
        else:
            raise pySCFNotConvergedError(
                pySCFNotConvergedErrorMessage(
                    pyscf_calc_params=pyscf_calc_params, mats_savefile=mats_savefile
                )
            )
    return mf


# Other
class AO:
    def __init__(self, ao_label, atom_id=None):
        if isinstance(ao_label, tuple):
            self.orientation = "unknown"
            self.ao_types = "unknown"
            self.atom_id = ao_label[0]
            self.angular = ao_label[1]
            return
        if atom_id is None:
            info = ao_label.split()
            ao_type_large = info[-1]
            if len(info) == 3:
                self.atom_id = int(info[0])
            else:
                # Must be one of those weird labels generated by pyscf.tools.molden.load.
                for char_id, char in enumerate(info[0]):
                    if char.isalpha():
                        self.atom_id = int(info[0][:char_id])
                        break
        else:
            self.atom_id = atom_id
            ao_type_large = ao_label
        for char_id, char in enumerate(ao_type_large):
            if char.isalpha():
                self.ao_type = ao_type_large[: char_id + 1]
                self.orientation = ao_type_large[char_id + 1 :]
                self.angular = orb_ang_mom[char]
                break

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return (
            ":atom_id:"
            + str(self.atom_id)
            + ":ao_type:"
            + self.ao_type
            + ":ang_momentum:"
            + str(self.angular)
            + ":orientation:"
            + self.orientation
        )


def generate_ao_arr(mol):
    return [AO(ao_label) for ao_label in mol.ao_labels()]


# Contains the same data as a pySCF Mean Field (MF) object.
class PseudoMF:
    def __init__(self, e_tot=None, mo_coeff=None, mo_occ=None, mo_energy=None):
        self.e_tot = e_tot
        self.mo_coeff = mo_coeff
        self.mo_occ = mo_occ
        self.mo_energy = mo_energy


# Stores data and mimics pySCF's Mole object when used in Pipek-Mezey localization
# or some other instances throughout the orb_ml module.
class PseudoMole:
    def __init__(self, ovlp_mat, atom_ao_ranges, angular_momenta):
        # Relevant data
        self.natm = ovlp_mat.shape[0]
        self.ovlp_mat = ovlp_mat
        self.atom_ao_ranges = atom_ao_ranges
        self.angular_momenta = angular_momenta
        # Irrelevant attributes only there to pass some of pySCF's checks.
        self.verbose = False
        self.stdout = "PseudoStdout"

    # The returned tuples are boundary indices of shells (first two entries) and atomic orbitals (second
    # pair of entries) correponding to a given atom. Since shell indices are not used in the localization procedure
    # their value is set arbitrarily.
    def offset_nr_by_atom(self):
        return [(0, 0, r1, r2) for (r1, r2) in self.atom_ao_ranges]

    def aoslice_by_atom(self):
        return self.offset_nr_by_atom()

    def ao_labels(self):
        output = []
        for atom_id, ao_range in enumerate(self.atom_ao_ranges):
            for ao_id in range(*ao_range):
                output.append((atom_id, self.angular_momenta[ao_id]))
        return output

    # We only know overlap integrals.
    def intor_symmetric(self, keyword):
        if keyword != "int1e_ovlp":
            raise Exception("Unimplemented option for PseudoMole class.")
        return self.ovlp_mat
