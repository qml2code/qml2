# For generating and processing ensembles (typically generated by morfeus).
import itertools
import os
from copy import deepcopy

# TODO make morfeus and rdkit dependences here optional to allow running some MSORF tests without morfeus-ml
from morfeus.conformer import ConformerEnsemble
from rdkit import Chem, RDLogger

from .basic_utils import checked_environ_val, dump2pkl, loadpkl
from .compound import Compound
from .data import room_T
from .jit_interfaces import array_
from .orb_ml.oml_compound import OML_Compound, OML_Slater_pair, OML_Slater_pairs
from .orb_ml.representations import OML_rep_params
from .utils import weighted_array, write_compound_to_xyz_file

# disable RdKit's verbose mode.
RDLogger.DisableLog("rdApp.*")

base_compound_class_dict = {
    "Compound": Compound,
    "OML_Compound": OML_Compound,
    "OML_Slater_pair": OML_Slater_pair,
    "OML_Slater_pairs": OML_Slater_pairs,
}

morfeus_random_seed = None


def set_morfeus_random_seed(new_morfeus_random_seed):
    """
    Set RNG seed used by morfeus when generating conformers for the Ensemble class.
    """
    global morfeus_random_seed
    morfeus_random_seed = new_morfeus_random_seed


def get_morfeus_random_seed(default_seed=None):
    """
    Get RNG seed used by morfeus when generating conformers for the Ensemble class.
    """
    if default_seed is None:
        return morfeus_random_seed
    else:
        return default_seed


class WeightedCompound:
    def __init__(self, compound, rho, ff_energy):
        self.compound = compound
        self.pre_renorm_rho = rho
        self.rho = rho
        self.ff_energy = ff_energy

    def calculated_energy(self):
        assert isinstance(self.compound, OML_Compound)
        return self.compound.e_tot

    def calculated_energy_diff(self):
        assert isinstance(self.compound, OML_Slater_pair)
        return self.compound.comps[1].e_tot - self.compound.comps[0].e_tot


class Ensemble:
    def __init__(
        self,
        SMILES=None,
        rdkit_obj=None,
        T=room_T,
        base_class_name="Compound",
        r_cut=None,
        ff_type="MMFF94",
        num_conformers=1,
        num_conformer_generations=1,
        savefile_prefix=None,
        compound_kwargs={},
        random_seed=None,
    ):
        self.rdkit_obj = rdkit_obj
        self.SMILES = SMILES
        if self.rdkit_obj is None:
            self.rdkit_obj = Chem.MolFromSmiles(self.SMILES)
            self.rdkit_obj = Chem.rdmolops.AddHs(self.rdkit_obj)
        self.T = T
        self.r_cut = r_cut
        self.ff_type = ff_type
        self.compound_kwargs = compound_kwargs
        self.base_compound_class = base_compound_class_dict[base_class_name]
        self.num_conformers = num_conformers
        self.num_conformer_generations = num_conformer_generations
        self.conformers = None
        self.filtered_conformers = None
        self.processed_conformers = None
        self.savefile_prefix = savefile_prefix
        self.random_seed = random_seed

    def get_nuclear_charges(self):
        return array_([a.GetAtomicNum() for a in self.rdkit_obj.GetAtoms()])

    def savefile_name(self, file_suffix):
        if self.savefile_prefix is None:
            return None
        return self.savefile_prefix + "_" + file_suffix + ".pkl"

    def successfully_recovered(self, attr_name, file_suffix=None):
        if file_suffix is None:
            file_suffix = attr_name

        filename = self.savefile_name(file_suffix)
        if filename is None:
            return False
        success = os.path.isfile(filename)
        if success:
            setattr(self, attr_name, loadpkl(filename))
        return success

    def save_attr2pkl(self, attr_name, file_suffix=None):
        if file_suffix is None:
            file_suffix = attr_name
        filename = self.savefile_name(file_suffix)
        if filename is None:
            return
        if os.path.isfile(filename):
            return
        dump2pkl(getattr(self, attr_name), filename)

    def create_compound(self, nuclear_charges, coordinates):
        return self.base_compound_class(
            nuclear_charges=nuclear_charges, coordinates=coordinates, **self.compound_kwargs
        )

    def conformer_generation(self):
        try:
            conformers = ConformerEnsemble.from_rdkit(
                self.rdkit_obj,
                n_confs=self.num_conformers,
                optimize=self.ff_type,
                n_threads=checked_environ_val("MORFEUS_NUM_THREADS", default_answer=1),
                random_seed=get_morfeus_random_seed(default_seed=self.random_seed),
            )
        except Exception as ex:
            if not isinstance(ex, ValueError):
                print("#PROBLEMATIC_MORFEUS:", self.SMILES)
            return None
        conformers.prune_rmsd()
        all_coordinates = conformers.get_coordinates()
        nuclear_charges = array_(conformers.elements)
        boltzmann_weights = conformers.boltzmann_weights(temperature=self.T)
        ff_energies = conformers.get_energies()
        weighted_compounds = weighted_array()
        for coordinates, boltzmann_weight, ff_energy in zip(
            all_coordinates, boltzmann_weights, ff_energies
        ):
            compound = self.create_compound(nuclear_charges, coordinates)
            weighted_compounds.append(WeightedCompound(compound, boltzmann_weight, ff_energy))
        return weighted_compounds

    def init_conformers(self):
        if self.conformers is not None:
            return
        if self.successfully_recovered("conformers"):
            return
        self.conformers = [
            self.conformer_generation() for _ in range(self.num_conformer_generations)
        ]
        self.save_attr2pkl("conformers")

    def init_filtered_conformers(self):
        if self.filtered_conformers is not None:
            return
        if self.successfully_recovered("filtered_conformers"):
            return
        self.init_conformers()
        self.filtered_conformers = deepcopy(self.conformers)
        for i in range(self.num_conformer_generations):
            self.filtered_conformers[i].normalize_sort_rhos_wcutoff(rho_cut=self.r_cut)
        self.save_attr2pkl("filtered_conformers")

    def filtered_conformer_compound_iterator(self):
        self.init_filtered_conformers()
        return itertools.chain(*self.filtered_conformers)

    def enumerated_filtered_conformer_compound_iterator(self):
        self.init_filtered_conformers()
        iters = []
        for gen_id, gen_list in enumerate(self.filtered_conformers):
            nconfs = len(gen_list)
            iters.append(zip(itertools.repeat(gen_id, nconfs), range(nconfs), gen_list))
        return itertools.chain(*iters)

    def run_calcs(self):
        if self.processed_conformers is not None:
            return
        if self.successfully_recovered("filtered_conformers", "processed_conformers"):
            return
        self.init_filtered_conformers()
        if self.base_compound_class is Compound:
            return
        for gen_id in range(self.num_conformer_generations):
            fc_list = self.filtered_conformers[gen_id]
            for conf_id in range(len(fc_list)):
                fc_list[conf_id].compound.run_calcs()

        self.save_attr2pkl("filtered_conformers", "processed_conformers")

    def generate_orb_reps(self, rep_params: OML_rep_params = OML_rep_params()):
        self.run_calcs()
        for wcomp in self.filtered_conformer_compound_iterator():
            wcomp.compound.generate_orb_reps(rep_params=rep_params)

    def write_filtered_xyzs(self, xyz_prefix="./"):
        self.init_filtered_conformers()
        for gen_id, conf_id, wcomp in self.enumerated_filtered_conformer_compound_iterator():
            xyz_name = xyz_prefix + "_" + str(gen_id) + "_" + str(conf_id) + ".xyz"
            write_compound_to_xyz_file(wcomp.compound, xyz_name)

    def mean_quant(self, quant_func):
        self.run_calcs()
        norm_const = 0.0
        val = 0.0
        for wcomp in self.filtered_conformer_compound_iterator():
            norm_const += wcomp.rho
            val += quant_func(wcomp) * wcomp.rho
        return val / norm_const

    # for printing out properties of the ensemble
    def filtered_conformer_numbers(self):
        return [len(conf_list) for conf_list in self.filtered_conformers]

    def mean_calculated_energy(self):
        return self.mean_quant(WeightedCompound.calculated_energy)

    def mean_calculated_energy_diff(self):
        return self.mean_quant(WeightedCompound.calculated_energy_diff)
